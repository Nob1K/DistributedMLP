// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/Compute.h"
#include "ML.hpp"
#include <string>
#include <cstdlib>
#include <ctime>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

class ComputeHandler : virtual public ComputeIf {
 public:
  float load_probability;

  ComputeHandler(float load_probability) {
    this->load_probability = load_probability;
  }

  bool check_availability() {
    std::srand(std::time(0));
    double probability = static_cast<double>(std::rand()) / RAND_MAX;
    printf("check_availability\n");
    return (probability > load_probability) ? true : false;
  }

  void train_model( ::weights& _return, const  ::weights& coordWeights, const std::string& train_fname, const double eta, const int32_t epochs) {
    printf("train_model\n");
    // initialize
    mlp model;
    vector<vector<double>> _V = coordWeights.v;
    vector<vector<double>> _W = coordWeights.w;
    // ml training
    std::cout << "init success: " << model.init_training_model(train_fname, _V, _W) << std::endl;
    std::cout << "training error: " << model.train(eta, epochs) << std::endl;
    vector<vector<double>> newV, newW;
    model.get_weights(newV, newW);
    calc_gradient(newV, _V);
    calc_gradient(newW, _W);
    // return calculated gradients
    _return.v = newV;
    _return.w = newW;
    std::cout << "validate error:" << model.validate("../letters/validate_letters.txt") << std::endl;
  }

};

int main(int argc, char **argv) {
  if (argc < 3) {
    printf("./compute_node <port> <load_probability>\n");
    return 1;
  }
  int port = std::stoi(argv[1]);
  float load_probability = std::stof(argv[2]);
  ::std::shared_ptr<ComputeHandler> handler(new ComputeHandler(load_probability));
  ::std::shared_ptr<TProcessor> processor(new ComputeProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

